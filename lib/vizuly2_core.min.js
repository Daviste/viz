/*! Vizuly2 29-07-2018 */
(function (global, factory) {  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :  typeof define === 'function' && define.amd ? define(['exports'], factory) : 	(factory((global.vizuly2 = global.vizuly2 || {})));  } (this, (function (exports) { 'use strict';
var vizuly2={};vizuly2.d3=window.d3v4||window.d3,vizuly2.d3?Number(vizuly2.d3.version.substr(0,1))<4&&console.log("WARNING - Your D3 Library v"+vizuly2.d3.version+" is not compatible with this version of Vizuly.   Please use D3 v4.0.0 or higher."):console.log("WARNING - No D3 library found for vizuly2!  Please load D3 library first."),vizuly2.core={},vizuly2.viz={},vizuly2.viz.layout={},vizuly2.viz.layout.CLUSTERED="CLUSTERED",vizuly2.viz.layout.STACKED="STACKED",vizuly2.viz.layout.OVERLAP="OVERLAP",vizuly2.viz.layout.STREAM="STREAM",vizuly2.svg={},vizuly2.ui={},vizuly2.assets={},vizuly2.core.component=function(t,u,r,e){u.parent=t,u.properties=r,u.id=vizuly2.core.util.guid(),u.selection=vizuly2.d3.select(t).append("div").attr("id","div_"+u.id).style("width","100%").style("height","100%");var a=u.styles=null,n={},o=[];o.push("mouseover"),o.push("mouseout"),o.push("mousedown"),o.push("click"),o.push("dblclick"),o.push("touch"),o.push("zoom"),o.push("zoomstart"),o.push("zoomend"),o.push("initialize"),o.push("validate"),o.push("measure"),o.push("update"),o.push("styled"),Object.getOwnPropertyNames(r).forEach(function(t,e,r){o.push(t+"_change")}),e&&0<e.length&&e.forEach(function(t){o.push(t)}),u.dispatch=vizuly2.d3.dispatch.apply(this,o);var i=function(){var a,n,o;return a=i,o=(n=u).properties,Object.getOwnPropertyNames(o).forEach(function(r,t,e){void 0===n[r]&&(n[r]=o[r],a[r]=function(t){if(!arguments.length)return n[r];var e=n[r];return n[r]=t,n[r]!==e&&n.dispatch.apply(r+"_change",this,[n[r],e]),a})}),i};return u.dispatch.component=i(),i.id=function(){return u.id},i.selection=function(){return u.selection},i.style=function(t,e){return arguments.length<2?n[t]?n[t]:u.styles[t]?u.styles[t]:null:(n[t]=e,i)},i.applyStyles=function(e){return Object.keys(e).forEach(function(t){i.style(t,e[t])}),i},i.defaultStyles=function(t){if(arguments.length<1)return a;a=t,u.styles=a},i.getStyle=function(t,e){return null!=n[t]?"function"==typeof n[t]?n[t].apply(i,e):n[t]:null!=u.styles[t]?"function"==typeof u.styles[t]?u.styles[t].apply(i,e):u.styles[t]:null},i.on=function(t,e){return u.dispatch.on(t,e),i},i.onChange=function(t,e){return u.dispatch.on(t+"_change",e),i},i.validate=function(){if(!e){var e=[];if(Object.getOwnPropertyNames(r).forEach(function(t){!u[t]&&Number(0!=u[t])&&e.push(t)}),0<e.length)throw new Error("vizuly2.core.util.component.validate(): "+e.concat()+" need to be declared");u.dispatch.apply("validate",this)}},i.applyCallbacks=function(t){t.forEach(function(t){u.dispatch.on(t.on,t.callback)})},i.showDataTip=function(t,e,r,a){if(u.dataTipRenderer&&null!=u.dataTipRenderer){var n=t.getBoundingClientRect(),o=150,i=70,s=vizuly2.d3.select("body").append("div").attr("class","vz-data-tip").style("width",o+"px").style("height",i+"px").style("display","none"),l=n.left,p=n.top+window.pageYOffset,d=u.dataTipRenderer(s,t,e,r,l,p);s.style("display","block"),d&&"object"==typeof d&&d.constructor===Array&&(l=d[0],p=d[1]);var c=s.nodes()[0].getBoundingClientRect();o=c.width,i=c.height,s.style("left",l?l+"px":n.left+n.width/2-o/2+"px").style("top",p?p+"px":n.top+window.pageYOffset-i-10+"px")}},i.removeDataTip=function(){vizuly2.d3.select(".vz-data-tip").remove()},u.dispatch.component},vizuly2.core.util={},vizuly2.core.util.size=function(t,e,r){var a={};return a.width=e-vizuly2.core.util.measure(t.left,e)-vizuly2.core.util.measure(t.right,e),a.height=r-vizuly2.core.util.measure(t.top,r)-vizuly2.core.util.measure(t.bottom,r),a.top=vizuly2.core.util.measure(t.top,r),a.left=vizuly2.core.util.measure(t.left,e),a.bottom=vizuly2.core.util.measure(t.bottom,r),a.right=vizuly2.core.util.measure(t.right,e),a},vizuly2.core.util.getTypedScale=function(t){return"string"==typeof t?vizuly2.d3.scaleBand():t instanceof Date?vizuly2.d3.scaleTime():vizuly2.d3.scaleLinear()},vizuly2.core.util.measure=function(t,e){if("string"==typeof t&&"%"==t.substr(t.length-1)){var r=Math.min(Number(t.substr(0,t.length-1)),100)/100;return Math.round(e*r)}return Number(t)},vizuly2.core.util.guid=function(){return"vzxxxxxxxx".replace(/[xy]/g,function(t){var e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)})},vizuly2.core.util.getDefs=function(t){var e=t.selection().selectAll("svg defs");return e.nodes()&&e.nodes().length<1&&(e=t.selection().select("svg").append("defs")),e},vizuly2.core.util.createCSSKey=function(t){return t="css"+(t=(t=String(t).replace(",","_")).replace(/[\s+,'+,\.,\(,\),\',\&,\/]/g,"")).toUpperCase()},vizuly2.core.util.aggregateNest=function(t,l,p){for(var e=t[0];e.values;)e=e.values[0];var n=[];function d(t,e){if(e)for(var r=0;r<n.length;r++){var a=n[r];null!=t[a]&&(t["childProp_"+a]=t[a]),e["childProp_"+a]=t["childProp_"+a]?t["childProp_"+a]:t[a]}}Object.getOwnPropertyNames(e).forEach(function(t){n.push(t)}),function t(e,r){for(var a=0;a<e.length;a++){var n=e[a];if(n.values){t(n.values,n);for(var o=0;o<n.values.length;o++)for(var i=n.values[o],s=0;s<l.length;s++)isNaN(n["agg_"+l[s]])&&(n["agg_"+l[s]]=0),n["agg_"+l[s]]=p(n["agg_"+l[s]],i["agg_"+l[s]])}else for(var s=0;s<l.length;s++)n["agg_"+l[s]]=Number(n[l[s]]),isNaN(n["agg_"+l[s]])&&(n["agg_"+l[s]]=0);d(n,r)}}(t)},vizuly2.core.util.format_YEAR_Mon_MonDay=function(t){var e=vizuly2.d3.timeFormat(".%L"),r=vizuly2.d3.timeFormat(":%S"),a=vizuly2.d3.timeFormat("%I:%M"),n=vizuly2.d3.timeFormat("%I %p"),o=vizuly2.d3.timeFormat("%a %d"),i=vizuly2.d3.timeFormat("%b %d"),s=vizuly2.d3.timeFormat("%b"),l=vizuly2.d3.timeFormat("%Y");return(vizuly2.d3.timeSecond(t)<t?e:vizuly2.d3.timeMinute(t)<t?r:vizuly2.d3.timeHour(t)<t?a:vizuly2.d3.timeDay(t)<t?n:vizuly2.d3.timeMonth(t)<t?vizuly2.d3.timeWeek(t)<t?o:i:vizuly2.d3.timeYear(t)<t?s:l)(t)},vizuly2.core.util.stackOffsetBaseline=function(t,e){if(1<(r=t.length)){var r,a=1,n=t[e[0]];for(n.length;a<r;++a)n=t[e[a]]}},vizuly2.core.util.rgbToHex=function(t){return rgb=String(t).match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i),rgb&&4===rgb.length?"#"+("0"+parseInt(rgb[1],10).toString(16)).slice(-2)+("0"+parseInt(rgb[2],10).toString(16)).slice(-2)+("0"+parseInt(rgb[3],10).toString(16)).slice(-2):""},vizuly2.svg.filter={},vizuly2.svg.filter.dropShadow=function(t,e,r,a){var n=Math.round(100*e)+"_"+Math.round(100*r)+"_"+Math.round(100*a),o=t.id(),i=vizuly2.core.util.getDefs(t).selectAll("#vz_filter_"+o+"_"+n).data([n]).enter().append("filter").attr("id","vz_filter_"+o+"_"+n).attr("class","vz-svg-filter-dropShadow").attr("width","300%").attr("height","300%");i.append("feGaussianBlur").attr("in","SourceAlpha").attr("stdDeviation",a),i.append("feOffset").attr("dx",e).attr("dy",r),i.append("feComponentTransfer").append("feFuncA").attr("type","linear").attr("slope",.2);var s=i.append("feMerge");return s.append("feMergeNode"),s.append("feMergeNode").attr("in","SourceGraphic"),"#vz_filter_"+o+"_"+n},vizuly2.svg.gradient={},vizuly2.svg.gradient.blend=function(t,e,r,a){var n,o,i,s,l=String(e).replace("#","")+String(r).replace("#",""),p="vz_gradient_blend_"+t.id()+"_"+l;"horizontal"==a?(n="100%",s=i=o="0%"):(i="100%",s=o=n="0%");var d=vizuly2.core.util.getDefs(t),c=d.selectAll("#"+p).data([l]);return(c=c.enter().append("linearGradient").attr("id",p).attr("class","vz-svg-gradient-blend").attr("x1",n).attr("x2",o).attr("y1",i).attr("y2",s)).append("stop").attr("offset","0%").attr("stop-color",e),c.append("stop").attr("offset","100%").attr("stop-color",r),c=d.selectAll("#"+p)},vizuly2.svg.gradient.radialBlend=function(t,e,r,a,n,o,i,s,l){var p=String(a).replace("#","")+String(n).replace("#","")+String(o).replace("%","")+String(i).replace("%",""),d="vz_gradient_radial_blend_"+t.id()+"_"+p,c=vizuly2.core.util.getDefs(t),u=c.selectAll("#"+d).data([p]);return(u=u.enter().append("radialGradient").attr("id",d).attr("class","vz-svg-gradient-radial-blend").attr("cx",e).attr("cy",r)).append("stop").attr("offset",o).attr("stop-color",a).attr("stop-opacity",void 0===s?1:s),u.append("stop").attr("offset",i).attr("stop-color",n).attr("stop-opacity",void 0===l?1:l),u=c.selectAll("#"+d)},vizuly2.svg.gradient.fade=function(t,e,r,a,n){n||(n=[0,1]),a||(a=[.75,.9]);var o,i,s,l,p=String(e).replace("#",""),d="vz_gradient_fade_"+t.id()+"_"+p;"horizontal"==r?(i="100%",l=s=o="0%"):(s="100%",l=i=o="0%");var c=vizuly2.core.util.getDefs(t),u=c.selectAll("#"+d).data([p]).enter().append("linearGradient").attr("id",d).attr("class","vz-svg-gradient-fade").attr("x1",o).attr("x2",i).attr("y1",s).attr("y2",l);return u.append("stop").attr("offset",100*n[0]+"%").attr("stop-color",e).attr("stop-opacity",a[0]),u.append("stop").attr("offset",100*n[1]+"%").attr("stop-color",e).attr("stop-opacity",a[1]),u=c.selectAll("#"+d)},vizuly2.svg.gradient.radialFade=function(t,e,r,a){a||(a=[0,1]),r||(r=[.75,.9]);var n=String(e).replace("#",""),o="vz_gradient_radial_fade"+t.id()+"_"+n,i=vizuly2.core.util.getDefs(t),s=i.selectAll("#"+o).data([n]).enter().append("radialGradient").attr("id",o).attr("class","vz-svg-gradient-radial-fade");return s.append("stop").attr("offset",100*a[0]+"%").attr("stop-color",e).attr("stop-opacity",r[0]),s.append("stop").attr("offset",100*a[1]+"%").attr("stop-color",e).attr("stop-opacity",r[1]),s=i.selectAll("#"+o)},vizuly2.svg.gradient.darker=function(t,e,r){var a,n,o,i,s=String(e).replace("#",""),l="vz_gradient_darker_"+t.id()+"_"+s;"horizontal"==r?(a="100%",i=o=n="0%"):(o="100%",i=n=a="0%");var p=vizuly2.core.util.getDefs(t),d=p.selectAll("#"+l).data([s]).enter().append("linearGradient").attr("class","vz-gradient-darker").attr("id",l).attr("x1",a).attr("x2",n).attr("y1",o).attr("y2",i);return d.append("stop").attr("offset","0%").attr("stop-color",e).attr("stop-opacity",.75),d.append("stop").attr("offset","100%").attr("stop-color",vizuly2.d3.rgb(e).darker()).attr("stop-opacity",.9),d=p.selectAll("#"+l)},vizuly2.svg.text={},vizuly2.svg.text.textArcPath=function(t,e){var r={};r.angle=e,r.startAngle=r.angle-179*.0174533,r.endAngle=r.angle+179*.0174533;var a=d3.arc().innerRadius(t).outerRadius(t)(r),n=/[Mm][\d\.\-e,\s]+[Aa][\d\.\-e,\s]+/.exec(a);return n&&(n=n[0]),n},vizuly2.svg.text.wrap=function(t,l,p,d){var c=t.attr("x"),e=t.attr("y");c=!c||isNaN(c)?0:c,e=!e||isNaN(e)?0:e;var u=d/3;t.each(function(){var t,e=d3.select(this),r=l.split(/\s+/).reverse(),a=[],n=0,o=d,i=e.attr("y"),s=1.1*parseFloat(d/2)+u;for(isNaN(s)&&(s=0),tspan=e.text(null).append("tspan").attr("x",c).attr("y",i).attr("y",s).style("font-size",d+"px");t=r.pop();)a.push(t),tspan.text(a.join(" ")),tspan.node().getComputedTextLength()>p&&(a.pop(),tspan.text(a.join(" ")),a=[t],tspan=e.append("tspan").attr("x",c).attr("y",++n*o+s+i).text(t).style("font-size",d+"px"))})};
 Object.keys(vizuly2).forEach(function (key) { exports[key] = vizuly2[key]});
 Object.defineProperty(exports, '__esModule', { value: true });})));
;//Legacy v3 code, some of these functions are more utilitarian than v4+

var d3v3 = {};

d3v3.layout = {};

d3v3.svg = {};

d3v3.functor = function (v) {
	return typeof v === "function" ? v : function () {
		return v;
	};
}

d3v3.merge = function (arrays) {
	var n = arrays.length,
	 m,
	 i = -1,
	 j = 0,
	 merged,
	 array;
	
	while (++i < n) j += arrays[i].length;
	merged = new Array(j);
	
	while (--n >= 0) {
		array = arrays[n];
		m = array.length;
		while (--m >= 0) {
			merged[--j] = array[m];
		}
	}
	
	return merged;
};


// Copies a variable number of methods from source to target.
d3v3.rebind = function (target, source) {
	var i = 1, n = arguments.length, method;
	while (++i < n) target[method = arguments[i]] = d3v3_rebind(target, source, source[method]);
	return target;
};

// Method is assumed to be a standard D3 getter-setter:
// If passed with no arguments, gets the value.
// If passed with arguments, sets the value and returns the target.
function d3v3_rebind(target, source, method) {
	return function () {
		var value = method.apply(source, arguments);
		return value === source ? target : value;
	};
}


d3v3.layout.hierarchy = function () {
	var sort = d3v3_layout_hierarchySort,
	 children = d3v3_layout_hierarchyChildren,
	 value = d3v3_layout_hierarchyValue;
	
	function hierarchy(root) {
		var stack = [root],
		 nodes = [],
		 node;
		
		root.depth = 0;
		
		while ((node = stack.pop()) != null) {
			nodes.push(node);
			if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
				var n, childs, child;
				while (--n >= 0) {
					stack.push(child = childs[n]);
					child.parent = node;
					child.depth = node.depth + 1;
				}
				if (value) node.value = 0;
				node.children = childs;
			} else {
				if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
				delete node.children;
			}
		}
		
		d3v3_layout_hierarchyVisitAfter(root, function (node) {
			var childs, parent;
			if (sort && (childs = node.children)) childs.sort(sort);
			if (value && (parent = node.parent)) parent.value += node.value;
		});
		
		return nodes;
	}
	
	hierarchy.sort = function (x) {
		if (!arguments.length) return sort;
		sort = x;
		return hierarchy;
	};
	
	hierarchy.children = function (x) {
		if (!arguments.length) return children;
		children = x;
		return hierarchy;
	};
	
	hierarchy.value = function (x) {
		if (!arguments.length) return value;
		value = x;
		return hierarchy;
	};
	
	// Re-evaluates the `value` property for the specified hierarchy.
	hierarchy.revalue = function (root) {
		if (value) {
			d3v3_layout_hierarchyVisitBefore(root, function (node) {
				if (node.children) node.value = 0;
			});
			d3v3_layout_hierarchyVisitAfter(root, function (node) {
				var parent;
				if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
				if (parent = node.parent) parent.value += node.value;
			});
		}
		return root;
	};
	
	return hierarchy;
};

// A method assignment helper for hierarchy subclasses.
function d3v3_layout_hierarchyRebind(object, hierarchy) {
	d3v3.rebind(object, hierarchy, "sort", "children", "value");
	
	// Add an alias for nodes and links, for convenience.
	object.nodes = object;
	object.links = d3v3_layout_hierarchyLinks;
	
	return object;
}

// Pre-order traversal.
function d3v3_layout_hierarchyVisitBefore(node, callback) {
	var nodes = [node];
	while ((node = nodes.pop()) != null) {
		callback(node);
		if ((children = node.children) && (n = children.length)) {
			var n, children;
			while (--n >= 0) nodes.push(children[n]);
		}
	}
}

// Post-order traversal.
function d3v3_layout_hierarchyVisitAfter(node, callback) {
	var nodes = [node], nodes2 = [];
	while ((node = nodes.pop()) != null) {
		nodes2.push(node);
		if ((children = node.children) && (n = children.length)) {
			var i = -1, n, children;
			while (++i < n) nodes.push(children[i]);
		}
	}
	while ((node = nodes2.pop()) != null) {
		callback(node);
	}
}

function d3v3_layout_hierarchyChildren(d) {
	return d.children;
}

function d3v3_layout_hierarchyValue(d) {
	return d.value;
}

function d3v3_layout_hierarchySort(a, b) {
	return b.value - a.value;
}

// Returns an array source+target objects for the specified nodes.
function d3v3_layout_hierarchyLinks(nodes) {
	return d3v3.merge(nodes.map(function (parent) {
		return (parent.children || []).map(function (child) {
			return {source: parent, target: child};
		});
	}));
}


d3v3.layout.pack = function () {
	var hierarchy = d3v3.layout.hierarchy().sort(d3v3_layout_packSort),
	 padding = 0,
	 size = [1, 1],
	 radius;
	
	function pack(d, i) {
		var nodes = hierarchy.call(this, d, i),
		 root = nodes[0],
		 w = size[0],
		 h = size[1],
		 r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function () {
			 return radius;
		 };
		
		// Recursively compute the layout.
		root.x = root.y = 0;
		d3v3_layout_hierarchyVisitAfter(root, function (d) {
			d.r = +r(d.value);
		});
		d3v3_layout_hierarchyVisitAfter(root, d3v3_layout_packSiblings);
		
		// When padding, recompute the layout using scaled padding.
		if (padding) {
			var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
			d3v3_layout_hierarchyVisitAfter(root, function (d) {
				d.r += dr;
			});
			d3v3_layout_hierarchyVisitAfter(root, d3v3_layout_packSiblings);
			d3v3_layout_hierarchyVisitAfter(root, function (d) {
				d.r -= dr;
			});
		}
		
		// Translate and scale the layout to fit the requested size.
		d3v3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
		
		return nodes;
	}
	
	pack.size = function (_) {
		if (!arguments.length) return size;
		size = _;
		return pack;
	};
	
	pack.radius = function (_) {
		if (!arguments.length) return radius;
		radius = _ == null || typeof _ === "function" ? _ : +_;
		return pack;
	};
	
	pack.padding = function (_) {
		if (!arguments.length) return padding;
		padding = +_;
		return pack;
	};
	
	return d3v3_layout_hierarchyRebind(pack, hierarchy);
};

function d3v3_layout_packSort(a, b) {
	return a.value - b.value;
}

function d3v3_layout_packInsert(a, b) {
	var c = a._pack_next;
	a._pack_next = b;
	b._pack_prev = a;
	b._pack_next = c;
	c._pack_prev = b;
}

function d3v3_layout_packSplice(a, b) {
	a._pack_next = b;
	b._pack_prev = a;
}

function d3v3_layout_packIntersects(a, b) {
	var dx = b.x - a.x,
	 dy = b.y - a.y,
	 dr = a.r + b.r;
	return 0.999 * dr * dr > dx * dx + dy * dy; // relative error within epsilon
}

function d3v3_layout_packSiblings(node) {
	if (!(nodes = node.children) || !(n = nodes.length)) return;
	
	var nodes,
	 xMin = Infinity,
	 xMax = -Infinity,
	 yMin = Infinity,
	 yMax = -Infinity,
	 a, b, c, i, j, k, n;
	
	function bound(node) {
		xMin = Math.min(node.x - node.r, xMin);
		xMax = Math.max(node.x + node.r, xMax);
		yMin = Math.min(node.y - node.r, yMin);
		yMax = Math.max(node.y + node.r, yMax);
	}
	
	// Create node links.
	nodes.forEach(d3v3_layout_packLink);
	
	// Create first node.
	a = nodes[0];
	a.x = -a.r;
	a.y = 0;
	bound(a);
	
	// Create second node.
	if (n > 1) {
		b = nodes[1];
		b.x = b.r;
		b.y = 0;
		bound(b);
		
		// Create third node and build chain.
		if (n > 2) {
			c = nodes[2];
			d3v3_layout_packPlace(a, b, c);
			bound(c);
			d3v3_layout_packInsert(a, c);
			a._pack_prev = c;
			d3v3_layout_packInsert(c, b);
			b = a._pack_next;
			
			// Now iterate through the rest.
			for (i = 3; i < n; i++) {
				d3v3_layout_packPlace(a, b, c = nodes[i]);
				
				// Search for the closest intersection.
				var isect = 0, s1 = 1, s2 = 1;
				for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
					if (d3v3_layout_packIntersects(j, c)) {
						isect = 1;
						break;
					}
				}
				if (isect == 1) {
					for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
						if (d3v3_layout_packIntersects(k, c)) {
							break;
						}
					}
				}
				
				// Update node chain.
				if (isect) {
					if (s1 < s2 || (s1 == s2 && b.r < a.r)) d3v3_layout_packSplice(a, b = j);
					else d3v3_layout_packSplice(a = k, b);
					i--;
				} else {
					d3v3_layout_packInsert(a, c);
					b = c;
					bound(c);
				}
			}
		}
	}
	
	// Re-center the circles and compute the encompassing radius.
	var cx = (xMin + xMax) / 2,
	 cy = (yMin + yMax) / 2,
	 cr = 0;
	for (i = 0; i < n; i++) {
		c = nodes[i];
		c.x -= cx;
		c.y -= cy;
		cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	}
	node.r = cr;
	
	// Remove node links.
	nodes.forEach(d3v3_layout_packUnlink);
}

function d3v3_layout_packLink(node) {
	node._pack_next = node._pack_prev = node;
}

function d3v3_layout_packUnlink(node) {
	delete node._pack_next;
	delete node._pack_prev;
}

function d3v3_layout_packTransform(node, x, y, k) {
	var children = node.children;
	node.x = x += k * node.x;
	node.y = y += k * node.y;
	node.r *= k;
	if (children) {
		var i = -1, n = children.length;
		while (++i < n) d3v3_layout_packTransform(children[i], x, y, k);
	}
}

function d3v3_layout_packPlace(a, b, c) {
	var db = a.r + c.r,
	 dx = b.x - a.x,
	 dy = b.y - a.y;
	if (db && (dx || dy)) {
		var da = b.r + c.r,
		 dc = dx * dx + dy * dy;
		da *= da;
		db *= db;
		var x = 0.5 + (db - da) / (2 * dc),
		 y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
		c.x = a.x + x * dx + y * dy;
		c.y = a.y + x * dy - y * dx;
	} else {
		c.x = a.x + db;
		c.y = a.y;
	}
}


d3v3.svg.diagonal = function () {
	var source = function (d) {
		 return d.source
	 },
	 target = function (d) {
		 return d.target
	 },
	 projection = function (d) {
		 return [d.x, d.y];
	 }
	
	function diagonal(d, i) {
		var p0 = source.call(this, d, i),
		 p3 = target.call(this, d, i),
		 m = (p0.y + p3.y) / 2,
		 p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];
		p = p.map(projection);
		return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	}
	
	diagonal.source = function (x) {
		if (!arguments.length) return source;
		source = d3v3.functor(x);
		return diagonal;
	};
	
	diagonal.target = function (x) {
		if (!arguments.length) return target;
		target = d3v3.functor(x);
		return diagonal;
	};
	
	diagonal.projection = function (x) {
		if (!arguments.length) return projection;
		projection = x;
		return diagonal;
	};
	
	return diagonal;
};

d3v3.svg.diagonal.radial = function () {
	var diagonal = d3v3.svg.diagonal(),
	 projection = function (d) {
		 return [d.x, d.y];
	 },
	 projection_ = diagonal.projection;
	
	diagonal.projection = function (x) {
		return arguments.length ?
		 projection_(function (x) {
		 	projection = x;
			 return function () {
				 var d = projection.apply(this, arguments),
					r = d[0],
					a = d[1] - halfπ;
				 return [r * Math.cos(a), r * Math.sin(a)];
			 };
		 })
		 : projection;
	};
	
	return diagonal;
};

vizuly2.d3v3 = d3v3;

